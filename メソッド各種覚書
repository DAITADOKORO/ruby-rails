メソッド各種覚書

そのまんまな奴ら
shuffle
sort



split

    "foo bar   baz".split
  =>["foo","bar","baz"]

    "fooxbarxbaz".split('x')
  =>["foo","bar","baz"]

join    splitの逆

    a
  =>["foo","bar","baz"]
    a.join
  =>"foobarbaz"

    a.join(', ')  #カンマ＋スペースを使って連結する
  =>"foo, bar, baz"




!   破壊的メソッド
元のメソッドの末尾に！を追加すると、内容の変更を行うことができる。

push

    a.push(6)  #6を配列に追加
  =>[42,8,17,6]

    a<<7    #7を追加。こっちのが楽。
  =>[42,8,17,6,7]

    a<<"foo"<<"bar"  #連続して追加する場合
  =>[52,8,17,6,7,"foo","bar"]


範囲（range)
(..)と入れてあげると、なかのものを展開

to_a

>> 0..9
=> 0..9
>> 0..9.to_a              #おっと、9に対してto_aを呼んでしまっていますね
NoMethodError: undefined method `to_a' for 9:Fixnum
>> (0..9).to_a            # 丸カッコを使い、範囲オブジェクトに対してto_aを呼びましょう
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

呼び出しは[]を使おう。

>> a = %w[foo bar baz quux]         # %wを使って文字列の配列に変換
=> ["foo", "bar", "baz", "quux"]
>> a[0..2]
=> ["foo", "bar", "baz"]

>> a = (0..9).to_a
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>> a[2..(a.length-1)]               # 明示的に配列の長さを使って選択
=> [2, 3, 4, 5, 6, 7, 8, 9]
>> a[2..-1]                         # 添字に-1を使って選択
=> [2, 3, 4, 5, 6, 7, 8, 9]


>> ('a'..'e').to_a
=> ["a", "b", "c", "d", "e"]


downcase  文字列中の大文字を小文字に変えた新しい文字列を返す。
upcase
小文字を大文字に
capitalize
先頭の小文字を大文字に
swapcase
小文字を大文字に、大文字を小文字に


ブロック

>> (1..5).each { |i| puts 2 * i }
2
4
6
8
10
=> 1..5

>> (1..5).each do |i|
?>   puts 2 * i
>> end
2
4
6
8
10
=> 1..5

二つはおんなじ。　　{}  do end

>> (1..5).each do |number|  # iでもnumberでも。
?>   puts 2 * number
>>   puts '--'    #間に__を差し込むこともできるよ。
>> end
2
--
4
--
6
--
8
--
10
--
=> 1..5


times
  n回繰り返し表示

>> 3.times { puts "Betelgeuse!" }   # 3.timesではブロックに変数を使っていない
"Betelgeuse!"
"Betelgeuse!"
"Betelgeuse!"
=> 3

map
  要素の数だけ繰り返しブロックを実行、ブロックの戻り値を集めた配列を作成して返す。(=collect)
map!
  その逆。(=collect!)

>> (1..5).map { |i| i**2 }          # 「**」記法は冪乗 (べき乗)
=> [1, 4, 9, 16, 25]
>> %w[a b c]                        # %w で文字列の配列を作成
=> ["a", "b", "c"]
>> %w[a b c].map { |char| char.upcase }
=> ["A", "B", "C"]
>> %w[A B C].map { |char| char.downcase }
=> ["a", "b", "c"]

  charなんて引数使うのだるいから、

>> %w[A B C].map { |char| char.downcase }
=> ["a", "b", "c"]
>> %w[A B C].map(&:downcase)
=> ["a", "b", "c"]

%ども

記法  代替前の構文  式展開 コード例  実行例
%,%Q  “ “ (文字列) あり  %Q(“abc”) \"abc\"
%q  ’ ’ (文字列) なし  %q(‘abc’) 'abc'
%W  [ ] (配列)  あり  %W(a b #{c})  ["a", "b", "c"]
%w  同上  なし  %w(a b #{c})  ["a", "b", "#{c}"]
%r  / / (正規表現)  あり  %r(/abc/) /\/abc\//
%s  : (シンボル)  あり  %s(abc) :abc
%I  [ ] (シンボルの配列) あり  %I(a b #{c})  [:a, :b, :c]
%i  同上  なし  %i(a b #{c})  [:a, :b, :#{c}]
%x  ` ` (コマンド実行)  あり  %x(ruby -v) "ruby 2.4.3p205"



merge

    ハッシュを結合させるよ。
    ”ハッシュオブジェクト.merge（追加するハッシュオブジェクト）”

hash1 = {"経済学" => 80, "財政学" => 70, "会計学" => 60}

hash2 = {"経営学" => 75, "会社法" => 65}

hash3 = hash1.merge(hash2)

p hash3

#=> {"経済学"=>80, "財政学"=>70, "会計学"=>60, "経営学"=>75, "会社法"=>65}

p hash1 #=> {"経済学"=>80, "財政学"=>70, "会計学"=>60}

p hash2 #=> {"経営学"=>75, "会社法"=>65}


！つけると。。。　hash1の方が結合したものに書き換えられる！

hash1 = {"経済学" => 80, "財政学" => 70, "会計学" => 60}

hash2 = {"経営学" => 75, "会社法" => 65}

hash3 = hash1.merge!(hash2)

p hash3 #=> {"経済学"=>80, "財政学"=>70, "会計学"=>60, "経営学"=>75, "会社法"=>65}

p hash1 #=>  {"経済学"=>80, "財政学"=>70, "会計学"=>60, "経営学"=>75, "会社法"=>65}

p hash2 #=>  {"経営学" => 75, "会社法" => 65}


キーが重複すると。。。引数の方が上書きされるよ。

hash1 = {"経済学" => 80, "財政学" => 70, "会計学" => 60}
hash2 = {"経営学" => 75, "財政学" => 65}
hash3 = hash1.merge(hash2)

p hash3 #=> {"経済学"=>80, "財政学"=>65, "会計学"=>60, "経営学"=>75}